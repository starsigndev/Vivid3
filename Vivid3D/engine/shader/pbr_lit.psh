#define dx 1.0

Texture2D    g_Texture;
SamplerState g_Texture_sampler;
Texture2D g_TextureNorm;
SamplerState g_TextureNorm_sampler;
Texture2D g_TextureRough;
SamplerState g_TextureRough_sampler;
Texture2D g_TextureMetal;
SamplerState g_TextureMetal_sampler;
Texture2D g_TextureAmbient;
SamplerState g_TextureAmbient_sampler;
TextureCube v_Shadow;
SamplerState v_Shadow_sampler;
TextureCube g_Environment;
SamplerState g_Environment_sampler;
#define PI 3.14159265359

struct PSInput
{
    float4 Pos   : SV_POSITION;
    float4 Color : COLOR0;
    float3 Norm : NORMAL0;
    float3 Uv : TEX_COORD;
    float3 TLP : NORMAL1;
    float3 TVP : NORMAL2;
    float3 TFP : NORMAL3;
    float3 v_LightPosition : POSITION1;
    float3 v_CameraPosition : POSITION2;
    float4 v_ExtraProp : POSITION3;
    float3 fragPos : POSITION4;
    float3 v_LightDiffuse : POSITION5;
    float3 localNormal : NORMAL4;
    int4 v_LightMode : POSITION8;
    float3 v_LightDir : NORMAL5;
    float3 v_ViewDir : NORMAL7;
    float3 v_LightCone : NORMAL6;
    float3x3 TBN : TRANSFORMMATRIX;
   // float3 Norm : NORMAL0;x

};

struct PSOutput
{
    float4 Color : SV_TARGET;
};


static const float3 sampleOffsetDirections[20] = {
   float3( dx,  dx,  dx), float3( dx, -dx,  dx), float3(-dx, -dx,  dx), float3(-dx,  dx,  dx),
   float3( dx,  dx, -dx), float3( dx, -dx, -dx), float3(-dx, -dx, -dx), float3(-dx,  dx, -dx),
   float3( dx,  dx,  0), float3( dx, -dx,  0), float3(-dx, -dx,  0), float3(-dx,  dx,  0),
   float3( dx,  0,  dx), float3(-dx,  0,  dx), float3( dx,  0, -dx), float3(-dx,  0, -dx),
   float3( 0,  dx,  dx), float3( 0, -dx,  dx), float3( 0, -dx, -dx), float3( 0,  dx, -dx)
};

float3 light_GetNormal(float2 uv)
{

    float3 tNormal = float3(0.5, 0.0f, 1.0f);

    tNormal = g_TextureNorm.Sample(g_TextureNorm_sampler, uv).rgb;

      tNormal = -1.0+tNormal * 2.0;
   // tNormal.y = -tNormal.y;

    return tNormal;

}

float light_GetDist(float3 lightPos,float3 fragPos,float lightRange)
{

  float xd = lightPos.x - fragPos.x;
    float yd = lightPos.y - fragPos.y;
    float zd = lightPos.z - fragPos.z;


    float dis = sqrt(xd * xd + yd * yd + zd * zd);

    if (dis < 0) {
        dis = -dis;
    }

    float dv = dis / lightRange;

    if (dv > 1.0) {
        dv = 1.0;
    }
    dv = 1.0 - dv;


    return dv;


}

float light_GetPointDiff(float3 TLP,float3 TFP,float3 TVP,float3 tNormal,float3 lightPos,float3 fragPos)
{

    //tNormal.z = tNormal.z+1
    //.0f;
    float3 lightDir = normalize(TLP - TFP);
    return max(dot(lightDir, tNormal),0.0);


}

float light_GetPointSpec(float3 TLP,float3 TFP,float3 TVP,float3 tNormal)
{

    float3 lightDir = normalize(TLP - TFP);
    float3 viewDir = normalize(TVP-TFP);
    float3 reflectDir = reflect(-lightDir,tNormal);
    float3 halfwayDir = normalize(lightDir+viewDir);

    return pow(max(dot(tNormal,halfwayDir),0.0),32.0);


}

float light_GetDirectional(float3 lightDir,float3 TLP,float3 TFP,float3 tNormal){

    float3 lDir = normalize(lightDir);
    return max(dot(lDir, tNormal),0.0);

}

float light_GetSpotFalloff(float3 lightPos,float3 lightDir,float3 fragPos,float lightCone)
{
      float3 lightPixel = normalize(fragPos - lightPos);
      float factor = dot(lightPixel,-lightDir);
       factor *= pow(max(factor,0.0f),lightCone);
    return factor;
}



float light_GetShadow(float3 fragPos,float3 lightPos,float lightRange){

    float3 fragToLight = fragPos - lightPos;
    float currentDepth = abs(distance(fragPos,lightPos));

    int samples = 20;
    float diskRadius = 0.0025f;
    float bias = 0.005;
    float shadowVal = 0;
    currentDepth = currentDepth / lightRange;

    for(int i=0;i<samples;i++){

        float closestDepth = v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).r;


        if(closestDepth>currentDepth-0.001 && closestDepth<currentDepth+0.0011)
        {
            shadowVal += 0;
        }else
        if( (currentDepth-0.0013)>closestDepth)
        {

         shadowVal +=1.0f;
        

        }

    }


    shadowVal = shadowVal / (float)samples;
   
 //   shadowVal = shadowVal * v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).g;
   


    shadowVal = 1.0 - shadowVal;
    
    //shadowVal =shadowVal * v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).g;

    

    return shadowVal;

}




float3 CalculateNormalMap(PSInput input)
{


    float3x3 TBN = input.TBN;

    float3 normalFromMap = g_TextureNorm.Sample(g_TextureNorm_sampler, input.Uv).xyz * 2.0 - 1.0;
    normalFromMap = normalize(mul(TBN, normalFromMap));

    return normalFromMap;
}
float3 FresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(float3 normal, float3 viewDir, float3 lightDir, float roughness)
{
    float NdotV = max(dot(normal, viewDir), 0.0);
    float NdotL = max(dot(normal, lightDir), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

float DistributionGGX(float3 normal, float3 halfVector, float roughness)
{
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;
    float NdotH = max(dot(normal, halfVector), 0.0);
    float NdotH2 = NdotH * NdotH;

    float nom = alpha2;
    float denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
    denom = PI * denom * denom;

    return nom / denom;
}

float3 CalculateLighting(PSInput input, float3 normal, float3 viewDir, float3 lightDir, float3 lightColor, float lightIntensity, float roughness, float metalness)
{
    float3 halfVector = normalize(lightDir + viewDir);

    // Fresnel-Schlick approximation
    float3 F0 = lerp(float3(0.04, 0.04, 0.04), lightColor, metalness);
    float3 F = FresnelSchlick(max(dot(halfVector, viewDir), 0.0), F0);

    // Geometry function (Smith Schlick-GGX)
    float G = GeometrySmith(normal, viewDir, lightDir, roughness);

    // Normal Distribution Function (GGX)
    float D = DistributionGGX(normal, halfVector, roughness);

    // Specular and diffuse components
    float3 kS = F;
    float3 kD = (1.0 - kS) * (1.0 - metalness);

    float NdotL = max(dot(normal, lightDir), 0.0);
    float NdotV = max(dot(normal, viewDir), 0.0);
    float3 nominator = D * G * F;
    float denominator = 4.0 * NdotV * NdotL + 0.001;
    float3 specular = nominator / denominator;

    float3 diffuse = g_Texture.Sample(g_Texture_sampler, input.Uv).rgb / PI;

    // Combine reflection with diffuse and specular
    float3 reflectDir = reflect(-viewDir, normal);
    //float3 envMapColor = g_Environment.SampleLevel(g_Environment_sampler, reflectDir, 0).rgb;
  float roughnessFactor = roughness * 0.05; // Adjust this scaling factor as needed
    float3 envMapColor = g_Environment.SampleLevel(g_Environment_sampler, reflectDir, roughnessFactor).rgb;
 envMapColor *= F * metalness;

    if(input.v_ExtraProp.y <= 0){
        envMapColor = float3(0, 0, 0);
    }

    return lightIntensity * NdotL * (kD * diffuse + specular) + envMapColor;
}



// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
    out PSOutput PSOut)
{

    float3 vd = -normalize(PSIn.TVP - PSIn.TFP);
    vd.x=-vd.x;


    
    


  //  float2 uv = ParallaxMapping(PSIn.Uv.xy,vd,0.02f);
    float2 uv = PSIn.Uv.xy;

    float4 col = float4(1, 0, 0, 1);

    float light = light_GetDist(PSIn.v_LightPosition,PSIn.fragPos,PSIn.v_ExtraProp.x);

    float3 tNormal = PSIn.Norm; // light_GetNormal(uv);

    float spec = 0.0;

    float shadowVal = 0;

    //LightValues lighting; 

    //lighting = CalculateLighting(PSIn.v_LightMode[0],tNormal,PSIn.TLP,PSIn.TFP,PSIn.TVP,PSIn.v_LightPos,PSIn.fragPos,PSIn.v_LightDir,PSIn.v_LightCone,PSIn.localNormal);

    shadowVal = light_GetShadow(PSIn.fragPos,PSIn.v_LightPosition,PSIn.v_ExtraProp.x);


    float3 albedo = g_Texture.Sample(g_Texture_sampler, PSIn.Uv).rgb;
    float3 normal = CalculateNormalMap(PSIn);
    float roughness = g_TextureRough.Sample(g_TextureRough_sampler, PSIn.Uv).r;
    float metalness = g_TextureMetal.Sample(g_TextureMetal_sampler, PSIn.Uv).r;
    float ambientOcclusion = g_TextureAmbient.Sample(g_TextureAmbient_sampler, PSIn.Uv).r;


  float3 viewDir = normalize(PSIn.v_CameraPosition - PSIn.fragPos);
    float3 lightDir = normalize(PSIn.v_LightPosition -PSIn.fragPos);

    float3 lightColor = CalculateLighting(PSIn, normal, viewDir, lightDir, PSIn.v_LightDiffuse, 1.0,roughness+PSIn.v_ExtraProp.z,metalness+PSIn.v_ExtraProp.w);
    lightColor *= ambientOcclusion*albedo;
    
    float4 fcol = float4(lightColor, 1.0) * shadowVal*light;
    fcol.a=1.0;


//    float4 ffcol =g_Texture.Sample(g_Texture_sampler, uv);// * float4(PSIn.lightDiff.x * light, PSIn.lightDiff.y * light, PSIn.lightDiff.z * light, 1.0)))*shadowVal;


  //  ffcol.a = 1.0;

   // spec = spec * shadowVal;

    //float3 tSpec = float3(1,1,1);//g_TextureSpec.Sample(g_TextureSpec_sampler,uv).rgb;

   // ffcol.rgb += float3(spec*PSIn.lightSpec.x,spec*PSIn.lightSpec.y,spec*PSIn.lightSpec.z) * PSIn.matSpec * tSpec;
    


    PSOut.Color = fcol;


}

