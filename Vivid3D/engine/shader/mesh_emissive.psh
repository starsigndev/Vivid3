#define dx 1.0

Texture2D    g_Texture;
SamplerState g_Texture_sampler;
Texture2D g_TextureNorm;
SamplerState g_TextureNorm_sampler;
Texture2D g_TextureSpec;
SamplerState g_TextureSpec_sampler;
TextureCube v_Shadow;
SamplerState v_Shadow_sampler;



struct PSInput
{
    float4 Pos   : SV_POSITION;
    float4 Color : COLOR0;
    float3 Norm : NORMAL0;
    float3 Uv : TEX_COORD;
    float3 TLP : NORMAL1;
    float3 TVP : NORMAL2;
    float3 TFP : NORMAL3;
    float3 lightPos : POSITION1;
    float3 viewPos : POSITION2;
    float4 lightProp : POSITION3;
    float3 fragPos : POSITION4;
    float3 lightDiff : POSITION5;
    float3 lightSpec : POSITION6;
    float3 localNormal : NORMAL4;
    float4 renderProps : POSITION7;
    int4 lightMode : POSITION8;
    float3 lightDir : NORMAL5;
    float3 viewDir : NORMAL7;
    float3 lightCone : NORMAL6;
    float3 matDiff : COLOR1;
    float3 matSpec : COLOR2;
   // float3 Norm : NORMAL0;x

};

struct PSOutput
{
    float4 Color : SV_TARGET;
};


static const float3 sampleOffsetDirections[20] = {
   float3( dx,  dx,  dx), float3( dx, -dx,  dx), float3(-dx, -dx,  dx), float3(-dx,  dx,  dx),
   float3( dx,  dx, -dx), float3( dx, -dx, -dx), float3(-dx, -dx, -dx), float3(-dx,  dx, -dx),
   float3( dx,  dx,  0), float3( dx, -dx,  0), float3(-dx, -dx,  0), float3(-dx,  dx,  0),
   float3( dx,  0,  dx), float3(-dx,  0,  dx), float3( dx,  0, -dx), float3(-dx,  0, -dx),
   float3( 0,  dx,  dx), float3( 0, -dx,  dx), float3( 0, -dx, -dx), float3( 0,  dx, -dx)
};

float3 light_GetNormal(float2 uv)
{

    float3 tNormal = float3(0.5, 0.0f, 1.0f);

    tNormal = g_TextureNorm.Sample(g_TextureNorm_sampler, uv).rgb;

      tNormal = -1.0+tNormal * 2.0;
   // tNormal.y = -tNormal.y;

    return tNormal;

}

float light_GetDist(float3 lightPos,float3 fragPos,float lightRange)
{

  float xd = lightPos.x - fragPos.x;
    float yd = lightPos.y - fragPos.y;
    float zd = lightPos.z - fragPos.z;


    float dis = sqrt(xd * xd + yd * yd + zd * zd);

    if (dis < 0) {
        dis = -dis;
    }

    float dv = dis / lightRange;

    if (dv > 1.0) {
        dv = 1.0;
    }
    dv = 1.0 - dv;


    return dv;


}

float light_GetPointDiff(float3 TLP,float3 TFP,float3 TVP,float3 tNormal,float3 lightPos,float3 fragPos)
{

    //tNormal.z = tNormal.z+1
    //.0f;
    float3 lightDir = normalize(TLP - TFP);
    return max(dot(lightDir, tNormal),0.0);


}

float light_GetPointSpec(float3 TLP,float3 TFP,float3 TVP,float3 tNormal)
{

    float3 lightDir = normalize(TLP - TFP);
    float3 viewDir = normalize(TVP-TFP);
    float3 reflectDir = reflect(-lightDir,tNormal);
    float3 halfwayDir = normalize(lightDir+viewDir);

    return pow(max(dot(tNormal,halfwayDir),0.0),32.0);


}

float light_GetDirectional(float3 lightDir,float3 TLP,float3 TFP,float3 tNormal){

    float3 lDir = normalize(lightDir);
    return max(dot(lDir, tNormal),0.0);

}

float light_GetSpotFalloff(float3 lightPos,float3 lightDir,float3 fragPos,float lightCone)
{
      float3 lightPixel = normalize(fragPos - lightPos);
      float factor = dot(lightPixel,-lightDir);
       factor *= pow(max(factor,0.0f),lightCone);
    return factor;
}



float light_GetShadow(float3 fragPos,float3 lightPos,float lightRange){

    float3 fragToLight = fragPos - lightPos;
    float currentDepth = abs(distance(fragPos,lightPos));

    int samples = 20;
    float diskRadius = 0.0025f;
    float bias = 0.005;
    float shadowVal = 0;
    currentDepth = currentDepth / lightRange;

    for(int i=0;i<samples;i++){

        float closestDepth = v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).r;


        if(closestDepth>currentDepth-0.0015 && closestDepth<currentDepth+0.0015)
        {
            shadowVal += 0;
        }else
        if( (currentDepth-0.0003)>closestDepth)
        {

         shadowVal +=1.0f;
        

        }

    }


    shadowVal = shadowVal / (float)samples;
   
 //   shadowVal = shadowVal * v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).g;
   


    shadowVal = 1.0 - shadowVal;
    
    //shadowVal =shadowVal * v_Shadow.Sample(v_Shadow_sampler,normalize(fragToLight)).g;

    

    return shadowVal;

}


// Note that if separate shader objects are not supported (this is only the case for old GLES3.0 devices), vertex
// shader output variable name must match exactly the name of the pixel shader input variable.
// If the variable has structure type (like in this example), the structure declarations must also be identical.
void main(in  PSInput  PSIn,
    out PSOutput PSOut)
{

  


    float4 ffcol =g_Texture.Sample(g_Texture_sampler,PSIn.Uv);



    PSOut.Color = ffcol;


}

